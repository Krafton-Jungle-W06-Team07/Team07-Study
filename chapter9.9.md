### 9.9동적 메모리 할당

- 할당기 종류
    - 명시적 할당기 :  어플리케이션이 명시적으로 할당된 블록을 반환해줄 것을 요구함
        
        EX) C 표준 라이브러리의 malloc 패키지
        
    - 묵시적 할당기 : 자동으로 사용하지않은 할당된 블록을 반환시켜줌
        
        EX) 가비지 컬렉터
        

### 9.9.1 malloc과 free 함수

- malloc 함수는 적절히 정렬된 최소 size 바이트를 갖는 메모리 블록의 포인터를 리턴함
- 32비트 모드에서는 주소가 항상 8의 배수이도록, 64비트모드에서는 16의 배수로 주소를 리턴함
- calloc 은 동적메모리를 0으로 초기화해줌
- sbrk
    - 커널의 brk 포인터에 incr을 더해서 힙을 늘리거나 줄임
    - 성공: 이전 brk 반환
    - 실패: -1 반환, errno를 ENOMEM으로 설정
        
![image](https://user-images.githubusercontent.com/116533378/205648608-2008ba2f-faa2-407e-8a87-96e1ad45dd3d.png)
        

### 9.9.3 할당기 요구사항과 목표

- 임의의 요청 순서 처리하기 - 할당기는 할당과 반환 요청의 순서에 대해 아무 가정도 할 수 없다.
- 블록들은 어떤 종류의 데이터 객체라도 저장할 수 있도록 하는 방식으로 정렬해야함
- 힙만 사용하기
- 블록 정렬하기
- 할당된 블록을 수정하지 않기 - 블록이 할당되면 수정/이동 불가능
- 목표
1. 처리량 극대화
2. 메모리 이용도 최대화

### 9.9.4 단편화

- 내부 단편화
    - 할당된 블록이 데이터보다 큰 경우
- 외부 단편화
    - 전체적인 메모리 공간에서는 할당 요청을 만족 시킬만한 공간이 있지만 요청을 처리할 수 있는 단일한 가용 블록이 없는 경우

### 9.9.5 구현 이슈

- 어떻게 가용 블록을 지속적으로 추적하는가
- 새롭게 할당된 블록을 배치하기 위한 가용 블록을 어떻게 선택하는가
- 배치 후 가용 블록의 나머지 부분들로 무엇을 할 것인가
- 방금 반환된 블록으로 무엇을 할 것인가

### 9.9.6 묵시적 가용 리스트

- 가용 블록이 헤더 내 필드에 의해서 묵시적으로 연결되는 형태
- 장점: 단순성
- 단점: 연산 비용이 전체 할당된 블록과 가용 블록의 수에 비례
- 한 블록은 1워드 헤더, 데이터, 추가적인 패딩으로 구성됨
- 헤더: 블록 크기와 블록의 할당/가용 상태
- 더블 워드 정렬 제한 조건이 부과된다면 블록 크기가 항상 8 이상이기 때문에 하위 3비트는 항상 0이다.
    
    → 하위 3비트에 가용/할당 상태 표시
    
![image](https://user-images.githubusercontent.com/116533378/205648688-4de02e29-9dfa-42fa-b2ca-aeb5f000354a.png)
    

### 9.9.7 할당한 블록의 배치

- 할당기가 요청에 맞는 가용 블록을 검색할 때 수행하는 방법에는 first fit, next fit, best fit을 주로 사용함
- first fit
    - 처음부터 검색해서 크기가 맞는 첫번재 블록을 선택함
    - 장점: 마지막에 가장 큰 가용 블록들을 남겨두는 경향
    - 단점: 앞쪽엔 작은 가용 블록들이 남아있기 때문에 큰 가용 블록을 검색할 때 오래걸림
- next fit
    - 이전 검색이 끝난 지점에서 검색을 시작함
    - 장점: 빠른 속도
    - 단점: 최악의 메모리 이용도 나올 수 있음
- best fit
    - 모든 가용 블록을 검사하여 크기가 가장 작은 블록을 선택함
    - 장점: 메모리 이용도
    - 단점: 힙을 완전히 다 검색해야함

### 9.9.8 가용블록의 분할

- 찾은 가용블록에서 어느 정도를 할당할 지에 대한 정책적 결정
- 가용 블록 전체 사용
    
    → 내부 단편화가 생김
    
- 할당한 블록과 새로운 가용 블록으로 분할

### 9.9.9 추가적인 힙 메모리 획득하기

- 인접한 가용 블록들을 연결해도 요청한 블록을 찾을 수 없을 때
1. 할당기가 커널에게 sbrk 함수를 호출하여 추가 힙 메모리를 요청함
2. 할당기가 추가 메모리를 한개의 더 큰 가용 블록으로 변환하여 가용 리스트에 삽입
3. 요청한 블록을 새로운 가용 블록에 배치

### 9.9.10 가용 블록 연결하기

- 오류 단편화 극복을 위해 연결(coalescing)과정으로 인접 가용 블록들을 통합
- 즉시 연결
    - 블록이 반환 될때마다 연결 수행
    - 단순하고 상수 시간 내에 수행 가능
    - 연결되고 잠시 후에 분할되는 쓰래싱의 형태를 유발할 수 있음
- 지연 연결
    - 일정 시간 기다림

### 9.9.11 경계 태그로 연결하기

- 각 블록의 끝부분에 헤더를 복사한 풋터(경계태그)를 추가
- 풋터는 항상 현재 블록의 시작 부분에서 한 워드 떨어진 곳에 위치함
- 할당기가 현재 블록을 반환할 때 가능한 모든 경우
1. 이전과 다음 블록이 모두 할당되어 있음
2. 이전 블록은 할당상태, 다음 블록은 가용상태
3. 이전 블록은 가용상태, 다음 블록은 할당상태
4. 이전 블록과 다음 블록 모두 가용상태

![image](https://user-images.githubusercontent.com/116533378/205648762-f8499b03-0d1a-435f-ae15-fff5e7a5b08a.png)

단점: 작은 크기의 블록을 다룰때 메모리 오버헤드가 발생할 수 있음

→ 현재 블록의 추가적인 하위 비트들 중 하나에 이전 블록의 할당/가용 비트를 저장하면 할당된 블록들은 풋터가 필요없어져서 최적화 가능

### 9.9.12 종합설계

- 묵시적 가용 리스트의 불변 형식
![image](https://user-images.githubusercontent.com/116533378/205648848-fe25978b-801f-4dd5-b39c-b3aefa66e3f7.png)
